# toyOS
一个玩具OS, 32bit

思路和实现上参考了《操作系统真象还原》

最终目标是实现一个简易的可交互的Shell

__TO-DO List：__

- [x] 虚拟内存及内存管理
- [x] 内核级线程
- [x] 用户态进程
- [x] 文件系统
- [ ] 交互Shell

### 硬盘分区
一共分主次两个硬盘，系统本身安装于主盘，采用的是MBR的引导模式，MBR->Boot Loader->Kernnel的过程

`MBR`位于磁盘`LBA 0号扇区`开始的**1**个扇区内

`Boot Loader`位于磁盘`LBA 2号扇区`开始的**4**个扇区内

`Kernel`位于磁盘`LBA 9号扇区`开始的**200**个扇区内

文件系统实现在从盘。这里可能不是很合理，若是按照商业系统的逻辑应该是现实现文件系统，再在相应分区安装操作系统

### 虚拟内存及内存管理
内存分页，一页为4Kb

内存管理采用位图管理，分配内存时按大小区分，大于1024字节的直接按页分配

若是小于1024字节，则在按页分配arena的基础上，用arena中的空闲块链进行分配和控制

为了实现方便，虽然开启了分页机制，但是并没有实现内存页与磁盘上的交换功能

![](./resource/内存布局.png)

### 线程和进程
PCB为1页大小

线程的调度，核心本质是通过时钟中断控制ESP指针切换来切换PCB，优先级的体现在于每个线程的运行时间片的长短

进程的实现基于线程，其中TSS的选择上仿效Linux，采用单TSS备份0级栈以及0级栈指针的做法。和线程最大的不同是进程的PCB中拥有页表地址，这也正是进程和线程最大的不同，进程真正拥有自己的独立虚拟内存空间

调度上没有用什么高效的算法，直接用队列循环调度

__进程fork__

进程的fork，先复制当前进程的PCB，然后再通过当前进程的虚拟池位图建立一个新页表，其中虚拟地址的对应和原进程中一模一样，最后伪造一个中断现场，将子进程加入到调度队列中等待调度执行。伪造的中断现场中，子进程的PCB里的eax修改成了0，代表新进程中拿到fork的返回值为0，而父进程的PCB中的eax不变，代表着子进程的pid。父进程是通过系统调用结束返回，而子进程是直接通过中断退出函数返回

__进程exec__

exec的实现，首先将elf文件从磁盘加载到内存，然后改变当前进程的PCB中的进程名，并把待执行进程所需的参数放入到约定的寄存器中，并将eip修改成elf的entry point，伪造中断现场，通过直接调用中断退出函数intr_exit来立即执行新进程。

### 文件系统
文件系统的实现模仿类Unix系统的inode

分区限定inode数量4096个，CPU按块（簇）大小操作硬盘，一块设置为一扇区，512字节。

inode共支持12个直接块和1个一级间接表，一个块为一扇区512字节，所以单文件最大支持140 * 512字节

__inode结构__

![](./resource/inode.png)

__文件系统布局__

![](./resource/文件系统布局.png)

__文件描述符与inode的对应__

![](./resource/文件描述符.png)

* 文件权限管理没有实现
* 文件类型，只包含文件夹和普通文件，并没有对普通文件进行细分
* 文件的stat，只包含inode编号、文件大小和文件类型三个字段
* 实现了文件操作的一些基本功能，如mkdir、pwd、cd等，详见fs.h
